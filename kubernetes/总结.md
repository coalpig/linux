
>首先是service的发现服务，也就是不同的pod之间怎么访问还有怎么映射端口让外部访问
- kube-proxy通过映射Linux内核的iptables规则，实现从Service到后端Endpoint列表的负载转发规则
- 主要通过iptables和ipvs
- iptables会虚拟出一个pod ip之上创建一个固定的虚拟ip叫cluster IP
- 同时会创建不同的server 名称
- 不同的名称创建出不同的Clusterip
- NodePort将内部端口暴露给宿主机端口
>其次是CoreDns是master怎么去访问所有node节点以及访问pod
- 一种是弄个环境变量，里面写着网关和ip等信息
- 一种是使用CoreDns,比如需要用pod名称去访问curl 域名都是需要coredns
- 首先node使用deployment后会产生ip和标签
- service通过标签知道pod对应的ip
- 然后把pod服务名称对应的ip存到coreDns
- 然后其他pod需要通讯的时候都是去问corednsq
- 知道想要访问的pod拿到ip后就自然可以访问了
service是通过iptables实现IP之间映射端口转发和通讯
CoreDns则是将这些规则记录下来，让其他node之间也能互相访问
终极总结
- **Service** 负责定义一组Pod的访问策略，并确保外部流量能够通过一个固定的地址（ClusterIP）或者节点上的端口（NodePort）访问到这些Pod。
- **CoreDNS** 负责将Service的名称解析为相应的IP地址，这样Pod就可以通过Service的名称来互相通信，而不需要知道后端Pod的具体IP地址。

总结来说，Service通过kube-proxy（可能使用iptables或其他机制）实现流量的转发，而CoreDNS则负责DNS解析，让Pod可以通过Service的名称来互相访问。两者共同工作，为Kubernetes集群内的服务发现和通信提供了支持。
![](attachments/Pasted%20image%2020240903001447.png)


CoreDns

![](attachments/Pasted%20image%2020240903001533.png)


就绪性探针



![](attachments/Pasted%20image%2020240903001554.png)