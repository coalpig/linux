
## 1.介绍

```
数据逻辑备份工具
MySQL 自带的客户端命令
可以实现远程和本地备份
```

## 2.重要参数

连接参数

```
-u 用户名
-p 密码
-S 本地socket文件路径
```

备份参数

```
-A  导出所有的库
-B  导出单库或多库
--master-data=2     标记全备的时候位于binlog哪个位置,=2这一行是个注释,固定为22行
--single-transaction  对于InnoDB表,通过快照备份表数据,不锁表备份,可以理解为热备
-R -E --triggers      备份特殊对象使用
```

## 3.备份命令

全备命令

```
mysqldump -uroot -p123 -A --master-data=2 --single-transaction -R -E --triggers > /backup/full_$(date +%F).sql
```

备份单个库或多个库

```
mysqldump -uroot -p123 -B 库名 --master-data=2 --single-transaction -R -E --triggers > /backup/abc_$(date +%F).sql
mysqldump -uroot -p123 -B 库名 库名 --master-data=2 --single-transaction -R -E --triggers > /backup/abc_$(date +%F).sql
```

备份单个表或多个表

```
mysqldump -uroot -p123 库名 表名 --master-data=2 --single-transaction -R -E --triggers > /backup/linux7_$(date +%F).sql
mysqldump -uroot -p123 库名 表名 表名 --master-data=2 --single-transaction -R -E --triggers > /backup/linux7_$(date +%F).sql
```

远程备份

```
mysqldump -uroot -p123 -h10.0.0.51 -A --master-data=2 --single-transaction -R -E --triggers > /backup/full_$(date +%F).sql
```

## 4.分库分表备份

备份思路

```
双层for循环
第一层for循环所有的库
第二层for循环库下所有的表
```

备份脚本

```
#!/bin/bash
for ku in $(mysql -N -e 'show databases;'|egrep -v 'mysql|schema|sys')
do
  mkdir /backup/$(date +%F)/$ku/ -p
  for biao in $(mysql -N -e "show tables from $ku;")
  do
      mysqldump -h127.0.0.1 $ku $biao --master-data=2 --single-transaction -R -E --triggers > /backup/$(date +%F)/$ku/$biao.sql
  done
done
```

技巧: 可以把账号密码写进配置文件里,这样就不会出现命令警告了

```
vim /etc/my.cnf
[client]
user=root
password=123
```

## 5.故障恢复演练

### 5.1 模拟环境

```
create database abc charset utf8mb4;
use abc
create table t1(id int);
insert into t1 values(1),(2),(3);
commit;
```

### 5.2 模拟周一23:00全备

```
mysqldump -uroot -p  -A  --master-data=2  --single-transaction  --max_allowed_packet=64M  -R -E  --triggers >/backup/full_$(date +%F).sql
```

查看GTID相关信息，GTID截取起点

SET @@GLOBAL.GTID_PURGED='9b52b744-eb82-11ea-986c-000c294983f8:1-6';

查看pos号，备份开始时binlog位置点信息

-- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=1028;

### 5.3 模拟周二白天数据变化

```
use abc;
create table t2 (id int);
insert into t2 values(1),(2),(3);
commit;
```

### 5.4 模拟周二下午2点，误删除了核心库

```
mysql> drop database abc;
```

### 5.5 恢复数据

第一步：查看全备时候的位置点在哪里

```
CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000007', MASTER_LOG_POS=2532
```

第二步：查看binlog定位终止点

```
# at 3119
#240110 15:24:15 server id 51  end_log_pos 3237 CRC32 0xd7f3dc06        Query   thread_id=2
     exec_time=0     error_code=0
SET TIMESTAMP=1641972255/*!*/;
DROP TABLE `t1` /* generated by server */
```

第三步：截取binlog

```
mysqlbinlog -d abc --start-position=2532 --stop-position=3119 /data/mysql_3306/logs/mysql-bin.000007 > /tmp/backup.sql
```

第四步：将全备和binlog导入到测试服务器里

```
scp /tmp/full_2024-01-10.sql 10.0.0.41:/opt/
scp /tmp/backup.sql  10.0.0.41:/opt/
```

第五步：测试服务器导入数据

```
mysql -uroot -p123 < full_2024-01-10.sql 
mysql -uroot -p123 < backup.sql
```

第六步：只导出被删除的表

```
mysqldump -uroot -p123 abc t1 > abc_t1.sql
```

第七步：将备份数据发送给生产服务器

```
scp abc_t1.sql 10.0.0.51:/opt/
```

第八步：生产服务器导入恢复的数据

```
set sql_log_bin=0;
source /opt/abc_t1.sql
set sql_log_bin=1;
```

## 6.mysqldump多种备份策略和恢复策略

### 6.1 场景

```
100G 全库数据 全库备份 30分钟-40分钟，恢复整库需要5倍时间2.5-3小时之间
一张表 1G 被误删除了
```

### 6.2 备份策略

第一种：full + binlog 增量备份思路

```
第一步：提取full全备中的故障表数据 ，恢复数据
sed -e'/./{H;$!d;}' -e 'x;/CREATE TABLE `t1`/!d;q'  full_2021-06-28.sql > create_table.sql
sed -n '/CREATE TABLE `t1` /,/\;/p' /data/backup/full.sql 

grep -i 'INSERT INTO `t1`' full_2021-06-28.sql > data.sql 

第二步：binlog中截取全备到误删除t1之间对于这张表的修改
```

第二种：单库单表备份+binlog 增量思路

```
第一步：恢复单表的备份
第二步：binlog中截取备份到误删除t1之间对于这张表的修改
```
