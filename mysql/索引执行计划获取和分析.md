# 执行计划获取和分析

## 1.命令介绍

```
explain
desc
```

## 2.使用方法

```
mysql> desc select * from city where countrycode='CHN';
mysql> explain select * from city where countrycode='CHN';
+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | city  | NULL       | ref  | CountryCode   | CountryCode | 3       | const |  363 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
```

## 3.执行计划信息介绍

![](attachments/Pasted%20image%2020240907134952.png)

```
table         ：此次查询访问的表
type          ：索引查询的类型（ALL、index、range、ref、eq_ref、const(system)、NULL）
  all 全表扫描
  const(system) 走主键
  ref 走了辅助索引
  rang 范围查询 where id>100,这种情况下索引基本没有太多用(也可以说效率很低)，还是会扫描很多行
  
  
possible_keys ：可能会应用的索引
key           : 最终选择的索引
key_len       ：索引覆盖长度，主要是用来判断联合索引应用长度。
ref 辅助索引最终还是要走一次主键索引会显示 const
rows          ：需要扫描的行数
Extra         ：额外信息
```
![](attachments/Pasted%20image%2020240907135354.png)
## 4.type信息详解

### 4.1 ALL 没有使用到索引

```
a. 查询条件没建立索引
mysql> desc select * from city where district='shandong';
b. 有索引不走
mysql> desc select * from city where countrycode != 'CHN';
mysql> desc select * from city where countrycode not in ('CHN','USA');
mysql> desc select * from city where countrycode like '%CH%';
```

### 4.2 index 全索引扫描

```
mysql> desc select countrycode from city;
```

### 4.3 range 索引范围扫描

```
会受到： B+TREE额外优化，叶子节点双向指针
mysql> desc select * from city where id<10;
mysql> desc select * from city where countrycode like 'CH%';

以下两种查询，大几率受不到叶子节点双向指针优化。
mysql> desc select * from city where countrycode in ('CHN','USA');
mysql> desc select * from city where countrycode='CHN' or countrycode='USA';

建议： 如果查询列重复值少的话，我们建议改写为 union all 
desc 
select * from city where countrycode='CHN'
union all
select * from city where countrycode='USA';
```

### 4.4 ref 辅助索引等值查询

desc select * from city where countrycode='CHN';

### 4.5 eq_ref : 多表连接查询中，非驱动表的连接条件是主键或唯一键时

```
mysql> desc select city.name,country.name 
from city 
left join country 
on city.countrycode=country.code 
where city.population<100;
```

### 4.6 const(system)： 主键或唯一键等值查询

```
mysql> desc select * from city where id=1;
```

### 4.7 NULL

```
mysql> desc select * from city where id=1000000000000000;
```

## 5.key_len信息详解

### 5.1 作用
![](attachments/Pasted%20image%2020240907142147.png)
```
用来判断联合索引应用的部分。
就是通过每个索引来计算字节使用的部分长度

例如： 
idx(a,b,c) 
我们希望应用联合索引的部分越多越好
```

### 5.2 如何计算

```
key_len=a+b+c 
列的key_len长度，按照每列的最大预留长度来做的计算。

create table t1 (
  id int,
  a int ,
  b char(10),
  c varchar(10));

最大存储预留长度（字节）: 
-------------------------------------------------------------------------------
  数据类型 ：      占用字节量             有not null           没有Not Null 
------------------------------------------------------------------------------- 
  数字类型：  
  tinyint      :  1字节                    1                   1+1
  int          ： 4字节                    4                   4+1
  bigint       ： 8字节                    8                   8+1
-------------------------------------------------------------------------------
  字符串类型： 
  utf8:  
  char(10)     ： 10*3字节 =30             30                  30+1
  varchar(10)  ： 10*3+2字节=32            32                  32+1
-------------------------------------------------------------------------------         
  utf8mb4: 
  char(10)     ：10*4字节 =40              40                  40+1
  varchar(10)  ：10*4字节+2 =42            42                  42+1
-------------------------------------------------------------------------------

use test; 
create table test (
  id int not null primary key auto_increment,
  a  int not null ,                            # 4  
  b  int ,                                     # 5
  c  char(10) not null ,                       # 40
  d  varchar(10),                              # 43
  e  varchar(10) not null                      # 42
)engine=innodb charset=utf8mb4;

alter table test add index idx(a,b,c,d,e);

5个列覆盖： 
4+5+40+43+42=134

4个列覆盖：
4+5+40+43=92

3个列覆盖： 
4+5+40=49 

2个列覆盖：
4+5=9 

应用1个列：
4
```

### 5.3 测试

```
mysql> desc select * from test where a=10 and b=10 and  c='a' and d='a' and e='a';
mysql> desc select * from test where a=10 and b=10 and  c='a' and d='a';
mysql> desc select * from test where a=10 and b=10 and  c='a';
mysql> desc select * from test where a=10 and b=10;
```

### 5.4 联合索引应用细节

条件：

```
联合索引应用要满足最左原则
a.建立联合索引时，选择重复值最少的列作为最左列。
b.使用联合索引时，查询条件中，必须包含最左列，才有可能应用到联合索引。
```

联合索引不同覆盖场景:

```
mysql> alter table t100w add index idx(num,k1,k2);
num :  5
k1  :  9
k2  :  17
```

a.全部覆盖 (key_len:31)

```
mysql> desc select * from t100w where num=913759  and k1='ej' and k2='EFfg';
mysql> desc select * from t100w where k1='ej' and k2='EFfg' and  num=913759 ;
mysql> desc select * from t100w where num=913759  and k1='ej' and k2 in('EFfg','abcd');
mysql> desc select * from t100w where num=913759  and k1='ej' and k2 like 'EF%';
```

说明：

```
a= and b= and c=  
b= and c= and a=
```

b.部分覆盖 idx(a,b,c)

```
where a =  and  b = 
where b =  and  a = 
where a = 
where a =  and   b> < >= <= in like between and   and  c= 

例如： 
mysql> desc select * from t100w where num=913759  and k1>'zz' and k2='EFfg';

总结：
如果联合索引中间出现了<>,between,like都会使得索引匹配截止于此。

如何优化？ 
(num,k1,k2)   ---->  (num,k2,k1)
mysql> desc select * from t100w where num=913759 and k2='EFfg' and k1>'zz';
```

c. 完全不覆盖 idx(a,b,c)

```
where  b  c  
where  b   
where  c
```

## 6.extra 额外的信息

```
using filesort   ---> group by \ order by \distinct \ union all 

mysql> desc select * from city where countrycode='CHN' order by population;

注意: where+order by 一定要点联合索引

优化：
mysql> alter table city add index idx_1(CountryCode,population);
mysql> show index from city;
mysql> desc select * from world.city where countrycode='CHN' order by population;
```

## 7.应用场景

```
数据库慢： 
a. 应急性的慢。
   show full processlist; ----> 慢语句 ----> explain SQL ---> 优化索引、改写语句
   
b. 间歇性慢。
   slowlog   ---->  慢语句  --->  explain SQL ---> 优化索引、改写语句
```
