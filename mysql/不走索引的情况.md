
## 1.没有查询条件或者查询条件没有建立索引

```
select * from city; 
select * from city where 1=1;
```

## 2.查询结果集是原表中的大部分数据，应该是15-25%以上

```
100w  num 有索引
desc select * from t100w where num>1;    ----> 全表

查询的结果集，超过了总数行数25%，优化器觉得就没有必要走索引了。
MySQL的预读功能有关。

可以通过精确查找范围，达到优化的效果。
1000000
desc select * from t100w where num>50000 and num<60000;
```

## 3.索引本身失效，统计信息不真实（过旧）

```
索引有自我维护的能力。
对于表内容变化比较频繁的情况下，有可能会出现索引失效。
一般是删除重建

现象:
有一条select语句平常查询时很快,突然有一天很慢,会是什么原因
select?  --->索引失效,统计数据不真实
innodb_index_stats  
innodb_table_stats  

立即更新：
mysql> ANALYZE TABLE world.city;
```

## 4.查询条件使用函数在索引列上或者对索引列进行运算

```
错误的例子：select * from test where id-1=9;
正确的例子：select * from test where id=10;
算术运算
函数运算
子查询
```

## 5.隐式转换导致索引失效

```
这样会导致索引失效. 错误的例子：
mysql> CREATE TABLE `num` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` char(10) NOT NULL,
  `num` char(10) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `inx` (`num`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;

mysql> desc num;
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| id    | int(11)  | NO   | PRI | NULL    | auto_increment |
| name  | char(10) | NO   |     | NULL    |                |
| num   | char(10) | NO   | MUL | NULL    |                |
+-------+----------+------+-----+---------+----------------+

mysql> insert into num(name,num)
values
('z3','123456'),
('l4','123'),
('w5','321');

mysql> ALTER TABLE num ADD INDEX inx(num);
mysql> SHOW INDEX FROM num;

mysql> DESC SELECT * FROM num WHERE num=123456;
mysql> DESC SELECT * FROM num WHERE num='123456';
```

## 6. <>,not in 不走索引（辅助索引）

```
EXPLAIN  SELECT * FROM teltab WHERE telnum  <> '110';
EXPLAIN  SELECT * FROM teltab WHERE telnum  NOT IN ('110','119');

mysql> select * from tab where telnum <> '1555555';
+------+------+---------+
| id  | name | telnum  |
+------+------+---------+
|    1 | a    | 1333333 |
+------+------+---------+
1 row in set (0.00 sec)

mysql> explain select * from tab where telnum <> '1555555';

单独的>,<,in 有可能走，也有可能不走，和结果集有关，尽量结合业务添加limit
or或in 可以修改成union all
EXPLAIN  SELECT * FROM teltab WHERE telnum  IN ('110','119');

改写成：
EXPLAIN SELECT * FROM teltab WHERE telnum='110'
UNION ALL
SELECT * FROM teltab WHERE telnum='119'
```

## 7.like "%_" 百分号在最前面不走

```
EXPLAIN SELECT * FROM teltab WHERE telnum LIKE '31%'  走range索引扫描
EXPLAIN SELECT * FROM teltab WHERE telnum LIKE '%110'  不走索引
%linux%类的搜索需求，可以使用elasticsearch 或者 mongodb 专门做搜索服务的数据库产品
```